---
title: "今更React環境を1から作る〜Create React Appを使わない"
date: "2021-08-30"
tags: ["コンピュータ"]
---

業務でReactを使っているのですが、一緒に使っているLaravelがうまいこと色々やってくれているおかげで、楽でいいもののどうにも動きがわからない……

というか、追加の設定をしようと思った時や、諸事情でLaravelから切り離そうとした際に意味不明でどハマりしてしまったので、反省の意味も込めてReactの環境を生で作り、供養することにしました。ついでにクソ簡単ですがアプリを作っているので、そのうち公開します。

前提としては、Laravel Mixは使わない、また、同様に？開発をいろいろお膳立てしてくれるツールをなるべく使わない、最小限の構築をめざします。ということなので、表題にある通りCreate React Appすら使いません。また、向上心が足りないので、TypeScriptについても考えないことにします。

### npmでパッケージ管理できるよう状態にする

projectというディレクトリに全て突っ込むことにします。

```shell
mkdir project
cd project
npm init
```

はい。npm関係はこのサイトを構築した際に入れたので、勘弁してください。

### 最低限必要なパッケージを吟味する

dependenciesとdevDependenciesに注意しながら、必要なパッケージを入れます。

```shell
npm i -D webpack webpack-cli webpack-dev-server html-webpack-plugin # webpack関係
npm i -D @babel/core @babel/preset-env @babel/preset-react babel-loader # babel関係
npm i react react-dom # react関係
```

すでに大量のパッケージが必要で、多少げんなりしてます。もしかしたらwebpackとwebpack-cli、webpack-dev-serverはglobal（`-g`）に入れてもいいのかも。[webpack-dev-server](https://webpack.js.org/configuration/dev-server/)は開発用のサーバでホットリロードに対応していて、現代を感じます。[html-webpack-plugin](https://webpack.js.org/plugins/html-webpack-plugin/)は、webpackがまとめたJSをロードするHTMLを自動生成してくれるらしいので、とりあえず入れました。

babel関係は、本体及びコードの解析物（構文木：AST）をJSファイルに変換するpreset類、そしてwebpackがbabelを呼べるようにするloaderを入れます。[preset-react](https://babeljs.io/docs/en/babel-preset-react)がJSXを扱って変換するもので、[preset-env](https://babeljs.io/docs/en/babel-preset-env)がブラウザやら規格が対応する文法の状況に合わせるものだそうです。なかなか大変なことをやってそうですね。

そしてやっと、React本体を入れます。

執筆現在、入ったバージョンは以下の通りです：

| パッケージ | バージョン |
| --- | --- |
| webpack | 5.51.1 |
| webpack-cli | 4.8.0 |
| html-webpack-plugin | 5.3.2 |
| @babel/core | 7.15.0 |
| @babel/preset-env | 7.15.0 |
| @babel/preset-react | 7.14.5 |
| babel-loader | 8.2.2 |
| react | 17.0.2 |
| react-dom | 17.0.2 |

webpack、babel関係はバージョンによって必要な記述やファイルが異なるため、ネット上に幾多の正しいけど今は動かない情報がたくさん溢れていて、結局は、エラーメッセージやら公式のドキュメントを見ながらやることになりました。楽をしてはいけないのだ……（

### ディレクトリ構成を決める

入れたパッケージの設定をするために、とりあえず仮で成果物を作ります。つまりは、ディレクトリ構成を決めてしまうということです。今回は、srcディレクトリを掘ってその中にソースファイルを、完成品をdistディレクトリに置くことにしました。

仮の成果物の中身はどうでもいいのですが、以下の通り、一応動いてることが確認できそうなものにしました。

```html fileName=src/index.html
<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Test</title>
    </head>
    <body>
        <div id="root">
        </div>
    </body>
</html>
```

```js fileName=src/index.js
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'

ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```

```js fileName=src/App.js
import React from 'react'

const App = () => (
    <p>Hello World!</p>
)

export default App
```

HTMLにできたJSファイルをロードする記述がないのですが、ここは先ほどのhtml-webpack-pluginがやってくれます。最初分からなくて自分で書いたら、二重にロードされてしまって「？？？」になってしまいました。

### webpack、babel、npm run scriptの設定をする

当たり前ですが、ここがキモです。まず方針を立てましょう。

webpackには動作モードがあって、設定のmodeというプロパティに`development`という文字列を与えると普通にJSが生成され、`production`という文字列を与えると自動で圧縮などをかけた本番用のファイルができあがるそうです。ということなので、npm run scriptからこの二つを状況に応じて与え分けなければなりません。

今回は、この二つを環境変数から与えわけることにします。webpackのベストプラクティスとしては設定ファイルを分けるそうなんですが、とりあえずそこは置いておくとします。

ということで、webpackの設定ファイルを生成します。

```shell
touch webpack.config.js
```

npm run scriptは次のようにしました：

```json fileNmae=package.json
 "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "NODE_ENV=development npx webpack serve --config webpack.config.js",
    "build": "NODE_ENV=production npx webpack --config webpack.config.js"
  },
```

`start`では、webpack-dev-serverを立ち上げてブラウザから開発中のファイルを動作させています。

やっと肝心のwebpackの設定です。めんどくさいんで一気にお見せします。

```js fileName=webpack.config.js
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

const isProduction = process.env.NODE_ENV === 'production'

module.exports = {
    mode: isProduction ? 'production' : 'development',
    entry: path.resolve(__dirname, 'src/index.js'),
    output: {
        filename: 'index.js',
        path: path.resolve(__dirname, 'dist')
    },
    devServer: {
        watchFiles: [path.join(__dirname, "src/*")],
        compress: true,
        host: '0.0.0.0',
    },
    module: {
        rules: [
            {
                test: /\.(js|jsx)$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: [
                            '@babel/preset-env',
                            '@babel/preset-react'
                        ]
                    }
                }
            }
        ]
    },
    resolve: {
        extensions: ['.js', '.jsx']
    },
    plugins: [
        new HtmlWebpackPlugin({template: path.resolve(__dirname, 'src/index.html')}),
    ]
}

```

pathモジュールの使い方がよくわかってないのは許してください。

modeプロパティが先ほど言ったwebpackの動作モードです。isProductionという変数を設けて、`development`と`production`の与え分けをしています。続いてentryプロパティがエントリポイント、outputプロパティが出力先などの設定です。なお、output.pathがdistのみになっていますが、webpack serve時にはここは読まれないので問題ありません。

devServerプロパティがwebpack-dev-server（webpack serve時）の設定です。watchFilesを設定しないとプロジェクト全体のファイルを見て際ビルドしてしまうようだったので、src以下に限定しました。compressは圧縮設定、hostは`0.0.0.0`として、他の端末からプライベートIPアドレスでアクセスできるようにしています。

moduleプロパティが変換対象のファイル指定です。拡張子がjs、jsxのファイルに対して、babel-loader経由でbabelによる処理を行います。この際、node_modulesディレクトリ内のファイルは対象としません。babel-loaderのオプションとして、presetを与えています。こちらは逆順で処理されるようなので、@babel/preset-env、@babel/preset-reactの順に記述します。

resolveプロパティがwebpackがバンドルするファイルの指定です。とりあえず拡張子がjs、jsxのファイルにします。

最後にpluginプロパティとして、webpackのプラグインを指定します。今回はhtml-webpack-pluginを使います。このプラグインが使うテンプレートファイルとして先ほどhtmlファイルのパスを与え、そのファイルにバンドル済みのファイルをロードするscript要素を付加してもらいます。

### ビルド

ここまでできれば、あとはビルドするだけになります。とりあえず開発ビルドを作りたいので、

```shell
npm run start
```

とします。これで、ブラウザから`http://localhost:8080`でアクセスできるはずです。また、適当にsrc内のファイルをいじって保存すれば、ビルドが走って変更内容がブラウザに反映されるはずです。あー疲れた。

本番ビルドは、設定の通り

```shell
npm run build
```

でよいはずです。


### 供養完了

ついでに`echo node_modules > .gitignore`して`git init`してみたりとかはしましたが、とりあえずこれで終わりです。確かに裏で行われてるさまざまなすごい処理を思うと、このぐらいのセットアップは屁でもないのかもしれませんが、こちら側で行う記述も結構な量だと思いました。確かにこれはCreate React Appみたいなものも流行るよなあ、という気持ちです。

これからも先人に感謝しつつ、使えるものは使っていこうと思いました。まる。

### おまけ（twin.macroの導入）

ここからじゃあアプリでも作るかとなった時に、今の状態だとスタイリングが何もありません。ということで、今流行りのTailwind CSSをJSXの中でも使えるようにしたtwin.macroも入れてみました。使用方法は、CSS Propsにしました。

やり方は公式サイトに載っていて、ほとんどそれをなぞるだけなのですが、一応メモしておきます。

まずは何はともあれインストールから：

```shell
npm i -D @emotion/babel-plugin-jsx-pragmatic babel-plugin-macros
npm i @emotion/react @emotion/styled twin.macro
```

公式サイトはこれらを全部Dependenciesで入れていて「？？？」だったのですが、babel系はdevDependenciesでええやろ、という考えに至ったのでとりあえずこうしています。

webpack.config.jsのbabel-loaderのoptionプロパティに、以下を追記します：

```js
plugins: [
    'babel-plugin-macros',
    [
        '@emotion/babel-plugin-jsx-pragmatic',
        {
            'export': 'jsx',
            'import': '__cssprop',
            'module': '@emotion/react'
        }
    ],
    [
        '@babel/plugin-transform-react-jsx',
        {
            'pragma': '__cssprop',
            'pragmaFlag': 'React.Fragment'
        }
    ]
]
```

どうもJSXの中のCSS Propsを見つけて@emotion/reactにかけたのちにマクロの解釈を行なっているように見えますが、詳細はよくわかりません。

ともあれ、あとはindex.jsからグローバルスタイルを読み込めばOKです。

```js fileName=src/index.js
import React from 'react'
import ReactDOM from 'react-dom'
import { GlobalStyles } from 'twin.macro'
import App from './App'

ReactDOM.render(
    <>
        <GlobalStyles />
        <App />
    </>,
    document.getElementById('root')
)
```

あとは好きなようにできます。

Tailwind CSSは、それっぽいデザインが集まっている小さいスニペットとしては便利で好きです。ただ、Utility Firstの考え方になかなか頭が切り替わらず、クラス命名をしたみたいになっちゃうんですよね。

こんな感じです：

```jsx

/* ... */

<div css={styleWrapper}>
    <p>hogehoge</p>
</div>

/* ... */

const styleWrapper = tw`
    w-2/3
    mx-auto
    border-2
    border-red-700
    rounded
`

/* ... */

```

こういうスタイル指定の記述がCSS Propsにベタ書きだと、なんとなく見にくいような気がしないでも。でもstyled-componentsはあんまり好かんし……。いや、こうしちゃうとstyled-componentsとあんま変わらんという説もありますね。

あと、twin.macroのグローバルスタイルは主にリセット関係しかなくて、ユーザが拡張するには@emotion/reactを経由する必要があるのはちょっと残念。

結局こんな感じの記述になってしまう：

```js
import React from 'react'
import ReactDOM from 'react-dom'
import tw, { GlobalStyles, css } from 'twin.macro'
import { Global } from '@emotion/react'
import App from './App'

ReactDOM.render(
    <>
        <GlobalStyles />
        <Global
            styles={css`
                body {
                    ${tw`bg-indigo-200`}
                }
            `}
        />
        <App />
    </>,
    document.getElementById('root')
)
```

`<GlobalStyles />`と`<Global styles={} />`が冗長な気がするので、前者でまとめられる機能ができたらいいな 